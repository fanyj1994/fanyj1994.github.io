<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>React Hooks 实践总结 | 范永健的 Blog.</title><link rel="stylesheet" type="text/css" href="./css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="./favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="./favicon.ico"><link rel="apple-touch-icon" href="./apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="./apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="./atom.xml"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">React Hooks 实践总结</h1><a id="logo" href="./.">范永健的 Blog.</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="./."><i class="fa fa-home"> 首页</i></a><a href="./archives/"><i class="fa fa-archive"> 归档</i></a><a href="./about/"><i class="fa fa-user"> 关于</i></a><a href="./atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">React Hooks 实践总结</h1><div class="post-meta">2020-11-17<span> | </span><span class="category"><a href="./categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="post-content"><p>最近一年几乎都在使用 TypeScript + Hooks 编写函数式组件，这一篇是我使用 hooks 的一些总结。</p>
<p>开始之前，看一个经典的计数器例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>点击了 &#123;count&#125; 次<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;Click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="每一帧都是独立的"><a href="#每一帧都是独立的" class="headerlink" title="每一帧都是独立的"></a>每一帧都是独立的</h4><blockquote>
<p>任意一次渲染中的<code>count</code>常量都不会随着时间改变。渲染输出会变是因为我们的组件被一次次调用，而每一次调用引起的渲染中，它包含的<code>count</code>值独立于其他渲染。 —— Dan Abramov</p>
</blockquote>
<p>在 React 组件中，通过改变状态来触发组件的重新 render，每次渲染都可以理解为一<strong>帧</strong>。在每一帧中，状态只是一个普通的变量，render 的时候，它都是独立不变的。</p>
<p>也就是说，在每次渲染中，所有的 state、props 以及 effects 在组件的<strong>任意位置</strong>都是固定的，我们无法直接获取过去或者未来渲染周期的状态。</p>
<p>state 变化，引发了视图的更新，从直觉上看来，这里是不是使用了数据绑定或者，观察者之类的高级技巧，实际上不是的，它只是函数的重复调用而已，count 是每次调用都独立的局部变量。</p>
<h4 id="更新-state"><a href="#更新-state" class="headerlink" title="更新 state"></a>更新 state</h4><p>在 react 中，state 或者 props 的改变，都会触发重新渲染。函数式组件以参数的形式接受 props，props 变化，整个组件都会重新渲染。<code>useState</code>在函数式组件内部创建了状态，并提供了一个改变状态的方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>几个值得注意的点：useState 的初始值可以是一个简单类型，也可以是复杂类型。同时它还可以接收一个函数，将函数的返回值作为该 state 的初始值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> [count, setCount] = useState(<span class="function">() =&gt;</span> a + b);</span><br></pre></td></tr></table></figure>

<p>既然每一帧的渲染中，state 都是独立的，其实就会有一个问题，当我们执行完 setCount 之后，并不会立即拿到最新的 count 的值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">setCount(count + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>也就是说，count 的值在本次渲染周期内是固定不变的，直到下一次渲染，count 才会更新为 1.这也是为什么感觉 state 的改变是异步的原因。</p>
<h4 id="获取未来或者过去的-state"><a href="#获取未来或者过去的-state" class="headerlink" title="获取未来或者过去的 state"></a>获取未来或者过去的 state</h4><p>如果想要获取到最新的 state 值，则可以通过给 setCount 方法传入一个函数来执行。</p>
<p>还有一种方法就是使用 <code>useRef</code>，它是一个所有帧共享的变量，你可以在任何时间改变它，然后在它未来的帧中访问它。也就是说，useRef 可以为渲染视图的特定一帧打一个快照进行保存。</p>
<h4 id="什么样的数据需要保存为内部-state"><a href="#什么样的数据需要保存为内部-state" class="headerlink" title="什么样的数据需要保存为内部 state"></a>什么样的数据需要保存为内部 state</h4><p>在实际使用中，一个组件可能会出现大量的 <code>useState</code>定义，这个时候，我们需要回头反思，如此多的 state 定义是否有必要？</p>
<p>我们知道，react 状态的变化会引发视图的更新，所以将一个变量定义为 state 的标准是：<strong>它的改变需要直接引发视图的更新？</strong>如果答案是否定的，那就完全不必定义一个 state 出来，而是通过一般的变量将其缓存起来。或者说，使用 <code>useRef</code>是一种不错的选择。</p>
<h4 id="管理复杂状态的两种选择：-useReducer-useContext"><a href="#管理复杂状态的两种选择：-useReducer-useContext" class="headerlink" title="管理复杂状态的两种选择： useReducer + useContext"></a>管理复杂状态的两种选择： useReducer + useContext</h4><p>对于一些需要全局使用的状态，如果需要在多层组件之间传递更新数据，这很容易造成逻辑混乱且不可追踪，则可以通过 useContext 来简化这一过程，以避免显示地在每一层组件之间传递 props，子组件可以在任何地方访问到该 context 的值。在下面的例子中，我们将终端的平台和版本通过 context 注入：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> client = &#123;</span><br><span class="line">  <span class="attr">mobile</span>: &#123;</span><br><span class="line">    <span class="attr">system</span>: <span class="string">&quot;android&quot;</span>,</span><br><span class="line">    <span class="attr">version</span>: <span class="string">&quot;8.0.0&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mac</span>: &#123;</span><br><span class="line">    <span class="attr">system</span>: <span class="string">&quot;MacOS&quot;</span>,</span><br><span class="line">    <span class="attr">version</span>: <span class="string">&quot;11.0.1&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> ClientContext = React.CreateContext(&#123;&#125;);</span><br><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">ClientContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;client.mac&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">ClientContext.Provider</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> client = useContext(ClientContext);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">      当前系统为&#123;client.system&#125;,系统版本为&#123;client.version&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在某一个节点注入 context，该组件及其所有下属组件都会共享这个 context。当该 context 的值发生变化时，其下的所有组件都会重新 render.</p>
<p><code>useReducer</code>，是改变 state 的另一种方式。顾名思义，就是 reducer 的 hooks 用法。reducer 接受一个改变 state 的方法，以及触发方法的 action，计算之后，返回新的 state.类似于这样 <code>(state, action) =&gt; newState</code>.<code>useReducer</code>在某些复杂场景下比 <code>useState</code>更实用，例如一个操作会引发 N 多个 state 的更新，或者说，state 本身嵌套很多层，更新的逻辑易遗漏，维护起来一片凌乱等等场景。</p>
<p>reducer 是一个纯函数，也就是说，它不包含任何 UI 和副作用操作。也就是说，只要输入的值不变，其输出的值也不会改变。</p>
<p>同样地，reducer 中的数据是 immutable 的，不要直接改变输入的 state，而是应该返回一个新的改变后的 state.</p>
<p>action 是一个用 type 标识的动作，例如对计数器的 increase、decrease 等，在 reducer 中，可以根据 action type 的不同，采用不同的数据处理。同时，它可以接收第二个参数 payload，传入执行该 action 需要的额外数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialArg, init);</span><br></pre></td></tr></table></figure>

<p><code>useReducer</code>接收一个 reducer 函数，以及一个初始的 state 值，暴露出计算之后的新 state，以及一个 dispatch 方法，它接收一个 action 为参数，用来触发相应的 reducer. 下面使用 <code>useReducer</code>重构计数器的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initialCount = &#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> countReducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;increase&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.count + <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;decrease&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.count - <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;reset&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: action.payload &#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> initialCount;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(countReducer, initialCount);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;state.count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &quot;increase&quot; &#125;)&#125;&gt;+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &quot;decrease&quot; &#125;)&#125;&gt;-1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &quot;reset&quot;, payload: initialCount.count &#125;)&#125;</span></span><br><span class="line"><span class="xml">      &gt;</span></span><br><span class="line"><span class="xml">        reset</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在某些复杂的场景中，reducer 的引入实际上将复杂的 state 更新行为剥离出来，单独在 reducer 之中维护，而组件的核心交互逻辑我们只需要关照 dispatch 了哪个 action，这样使得代码可读性大大提高，组件的核心逻辑也会清晰明了。同时，对于不涉及多层组件交互的状态，并不适合使用 reducer 来维护，这样，反而增加了维护的复杂度。</p>
<p>在一些复杂场景下，结合 <code>useContext</code>和<code>useReducer</code>可以发挥出十分强大的威力。一般的做法是，可以把 state 和 dispatch 方法通过 context 注入，这样，很方便地实现了状态的集中管理和更新。这种方法最好不要滥用，因为集中管理、处处可以变更的方式虽然看起来方便很多，但在 context 的作用范围处处都可以通过 dispatch 来更新 state，这样很容易造成 state 的更新不可追踪。</p>
<p>一般情况下，这种模式适合多层组件状态交互十分密集，且数据具有较好的完整性和共享需要，整个 state 描述的是同一件事，而不是把任意的数据都塞进去维护，这样写起来一时爽，维护起来火葬场~</p>
<h4 id="副作用管理"><a href="#副作用管理" class="headerlink" title="副作用管理"></a>副作用管理</h4><p><code>useEffect</code>和<code>useLayoutEffect</code>都是用来执行视图之外的副作用。前者在每次状态更新且视图也渲染完毕之后执行。后者则是在 DOM 更新完毕，但页面渲染之前执行，所以会阻塞页面渲染。</p>
<p>如前所述，在每一帧的渲染中，<code>useEffect</code> 中使用的 state 和 props 也是独立不变的。</p>
<p>可以通过给它传入第二个参数，一个依赖数组，来跳过不必要的副作用操作，React 通过对比依赖数组的值是否发生变化来决定是否执行副作用函数。当第二个参数为一个空数组的时候，意味着这个 Effects 只会执行一次。</p>
<p>对于依赖数组，使用不当经常会遇到各种各样的重复渲染的情况。不要添加不必要的依赖在数组中，因为依赖项越多，意味着该 Effects 被多次执行的概览越大。例如，在下面的场景中，如果需要在 Effects 中更新 state，不必将该 state 传入依赖数组，而是通过给 setCount 传入回调的方式去获得当前 state：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// setCount(count + 1); 这种方式会引入一个 state 的依赖项。</span></span><br><span class="line">  setCount(<span class="function">(<span class="params">count</span>) =&gt;</span> count + <span class="number">1</span>);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure>

<p>在 React 官方的文档中，还提到了两种需要避免重复渲染的情况及处理方式：</p>
<ol>
<li>当依赖项中传入一个函数时，通过使用 <code>useCallback</code>来包裹函数避免函数反复被创建；</li>
<li>当依赖项中传入数组或者对象等引用类型，通过使用 <code>useMemo</code>来缓存处理它。</li>
</ol>
<h4 id="使用-useMemo-和-useCallback"><a href="#使用-useMemo-和-useCallback" class="headerlink" title="使用 useMemo 和 useCallback"></a>使用 useMemo 和 useCallback</h4><p>如上所述，合理地使用 <code>useMemo</code>和<code>useCallback</code>能够避免不必要的渲染。当对象或者数组作为 props 传入的时候，可以使用 <code>useMemo</code>来缓存对象，使其在必要的时候更新：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = useMemo(<span class="function">() =&gt;</span> (&#123; id &#125;), [id]);</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">ComponentA</span> <span class="attr">data</span>=<span class="string">&#123;data&#125;</span> /&gt;</span></span>;</span><br></pre></td></tr></table></figure>

<p>只要 id 不变，Component 就不会重新渲染。</p>
<p><code>useMemo</code> 同样可以用来缓存组件内部的部分 React Element ，以避免重复渲染并没有变化的部分。</p>
<p>使用 <code>useMemo</code> 或者 <code>useCallback</code> 并不是绝对会提升性能。如果你缓存的数据永远不会改变或者说，每一次都会改变，那大可不必使用这两个 hooks，毕竟它们需要额外的计算成本以及存储空间，有的时候得不偿失。</p>
<p>最后，在<a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/thinking-in-react.html">React 哲学</a>一文中，官方给出了一种使用 React 来构建应用的思路，我觉得十分赞。这篇文章中提到，开始的时候，找出应用所需的最小集合，其他数组均有它们计算而出。</p>
</div><div class="tags"><a href="./tags/%E5%89%8D%E7%AB%AF/"><i class="fa fa-tag"></i>前端</a><a href="./tags/React/"><i class="fa fa-tag"></i>React</a></div><div class="post-nav"><a class="pre" href="./2020/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%801%EF%BC%9A%E4%BB%8E%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E5%88%B0%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%80%A7%E8%83%BD/">计算机基础1：从程序执行到计算机性能</a><a class="next" href="./2019/12/01/2019-12-01-%E7%BE%A4%E5%B1%B1%E7%9A%84%E5%8F%AC%E5%94%A4/">《进入空气稀薄地带》：群山的召唤</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://fanyj1994.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="./categories/%E5%85%B6%E4%BB%96/">其他</a></li><li class="category-list-item"><a class="category-list-link" href="./categories/%E5%89%8D%E7%AB%AF/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="./categories/%E5%8E%9F%E5%88%9B/">原创</a></li><li class="category-list-item"><a class="category-list-link" href="./categories/%E6%8A%80%E6%9C%AF/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="./categories/%E6%8A%80%E6%9C%AFgit-clone-https-github-com-zhwangart-hexo-theme-ocean-git-themes-ocean/">技术git clone https://github.com/zhwangart/hexo-theme-ocean.git themes/ocean</a></li><li class="category-list-item"><a class="category-list-link" href="./categories/%E7%94%9F%E6%B4%BB/">生活</a></li><li class="category-list-item"><a class="category-list-link" href="./categories/%E7%BC%96%E7%A8%8B/">编程</a></li><li class="category-list-item"><a class="category-list-link" href="./categories/%E8%A7%82%E5%BD%B1/">观影</a></li><li class="category-list-item"><a class="category-list-link" href="./categories/%E9%98%85%E8%AF%BB/">阅读</a></li><li class="category-list-item"><a class="category-list-link" href="./categories/%E9%9A%8F%E7%AC%94/">随笔</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="./tags/%E5%85%B6%E4%BB%96/" style="font-size: 15px;">其他</a> <a href="./tags/%E9%87%91%E5%BA%B8/" style="font-size: 15px;">金庸</a> <a href="./tags/%E5%89%8D%E7%AB%AF/" style="font-size: 15px;">前端</a> <a href="./tags/%E8%A5%BF%E6%96%B9%E6%96%87%E5%AD%A6/" style="font-size: 15px;">西方文学</a> <a href="./tags/%E9%9A%8F%E7%AC%94/" style="font-size: 15px;">随笔</a> <a href="./tags/Web/" style="font-size: 15px;">Web</a> <a href="./tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" style="font-size: 15px;">浏览器</a> <a href="./tags/%E8%A7%82%E5%BD%B1/" style="font-size: 15px;">观影</a> <a href="./tags/HTTP/" style="font-size: 15px;">HTTP</a> <a href="./tags/%E5%BD%93%E4%BB%A3%E6%96%87%E5%AD%A6/" style="font-size: 15px;">当代文学</a> <a href="./tags/Vue/" style="font-size: 15px;">Vue</a> <a href="./tags/CSS/" style="font-size: 15px;">CSS</a> <a href="./tags/%E7%BC%96%E7%A8%8B/" style="font-size: 15px;">编程</a> <a href="./tags/%E7%A8%8B%E5%BA%8F%E5%91%98/" style="font-size: 15px;">程序员</a> <a href="./tags/%E7%8E%B0%E4%BB%A3%E6%96%87%E5%AD%A6/" style="font-size: 15px;">现代文学</a> <a href="./tags/%E5%AF%84%E8%AF%AD/" style="font-size: 15px;">寄语</a> <a href="./tags/React/" style="font-size: 15px;">React</a> <a href="./tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/" style="font-size: 15px;">年终总结</a> <a href="./tags/%E5%B0%8F%E8%AF%B4/" style="font-size: 15px;">小说</a> <a href="./tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" style="font-size: 15px;">计算机基础</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="./2021/01/10/%E3%80%90%E4%B9%A6%E3%80%91%E3%80%8A%E5%B1%B1%E8%8C%B6%E6%96%87%E5%85%B7%E5%BA%97%E3%80%8B%E2%80%94%E2%80%94%E6%85%A2%E7%9A%84%E5%8A%9B%E9%87%8F/">【书】《山茶文具店》——慢的力量</a></li><li class="post-list-item"><a class="post-list-link" href="./2021/01/09/2021%E7%9A%84%E5%AF%84%E8%AF%AD/">2021的寄语</a></li><li class="post-list-item"><a class="post-list-link" href="./2020/12/18/%E5%86%99%E5%9C%A82020%E7%9A%84%E6%9C%AB%E5%B0%BE/">写在2020的末尾</a></li><li class="post-list-item"><a class="post-list-link" href="./2020/12/18/about%20me/">关于我</a></li><li class="post-list-item"><a class="post-list-link" href="./2020/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%801%EF%BC%9A%E4%BB%8E%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E5%88%B0%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%80%A7%E8%83%BD/">计算机基础1：从程序执行到计算机性能</a></li><li class="post-list-item"><a class="post-list-link" href="./2020/11/17/React%20Hooks%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/">React Hooks 实践总结</a></li><li class="post-list-item"><a class="post-list-link" href="./2019/12/01/2019-12-01-%E7%BE%A4%E5%B1%B1%E7%9A%84%E5%8F%AC%E5%94%A4/">《进入空气稀薄地带》：群山的召唤</a></li><li class="post-list-item"><a class="post-list-link" href="./2019/11/27/2019-11-27-%E3%80%8A%E6%B1%9F%E5%9F%8E%E3%80%8B%EF%BC%9A%E7%86%9F%E6%82%89%E5%8F%88%E9%99%8C%E7%94%9F%E7%9A%84%E6%99%AF%E8%87%B4/">《江城》：熟悉又陌生的景致</a></li><li class="post-list-item"><a class="post-list-link" href="./2019/10/04/2019-10-04-JS%E5%9F%BA%E7%A1%80%E5%9B%9E%E5%BD%9203-%E8%B0%88%E8%B0%88%E9%97%AD%E5%8C%85/">JS基础回归03：谈谈闭包</a></li><li class="post-list-item"><a class="post-list-link" href="./2019/09/21/2019-09-21-JS%E5%9F%BA%E7%A1%80%E5%9B%9E%E5%BD%9202%EF%BC%9Athis%E5%88%B0%E5%BA%95%E6%8C%87%E5%90%91%E5%93%AA%E9%87%8C/">JS基础回归02：this 到底指向哪里</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="./." rel="nofollow">范永健的 Blog..</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="./js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="./js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="./js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="./js/smartresize.js?v=1.0.0"></script></div></body></html>